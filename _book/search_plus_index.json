{"./":{"url":"./","title":"简 介","keywords":"","body":"简介 本项目是一套基于NodeJS、Koa2的Vue SSR解决方案，对提高首屏渲染速度、SEO优化等有明显提升。 我希望此项目能孕育出更多上层框架，帮助开发团队和开发人员降低开发和维护成本。 如果对你有所帮助，欢迎star 主要技术栈 NodeJS Koa2 Vue, Vuex, Vue-router element-ui Webpack4 axios babel7 eslint css、scss、postcss pm2 log4j Copyright ©大数据项目组 2019 all right reserved，powered by Gitbook本文档更新于： 2019-11-24 22:06 "},"chapter1/1.1.html":{"url":"chapter1/1.1.html","title":"Vue SSR是什么？","keywords":"","body":"Vue SSR是什么？ 后端渲染、CSR 、SSR区别 传统的后端渲染 写模板文件， 服务端将数据和模板渲染为HTML文档并返回给浏览器，适用于任何后端语言：PHP、Java、Python、GO等。 缺点： 前后端不分离 前后端不分离、代码不好维护 查看新页面就要请求服务器，刷新页面，体验不好 客户端渲染(CSR) 整个渲染在浏览器端使用JS来完成，配合 history.pushState等方式来做单页应用（SPA: Single-Page Application），也收到不错的体验效果。 缺点： 首屏加载慢 不利于SEO 同构应用(SSR) 类似于 React，Vue 2.0 等前端框架来做服务端渲染。 使用这些框架来做服务端渲染的兼顾了上面的几个优点。写一份代码就可以跑在服务端和浏览器端，在服务器端执行一次，用于实现服务器端渲染（首屏直出），在客户端再执行一次，用于接管页面交互，实现前后端同构。 Vue SSR是什么？ Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记\"激活\"为客户端上完全可交互的应用程序。 服务器渲染的 Vue.js 应用程序也可以被认为是\"同构\"或\"通用\"，因为应用程序的大部分代码都可以在服务器和客户端上运行。 Copyright ©大数据项目组 2019 all right reserved，powered by Gitbook本文档更新于： 2019-11-24 21:45 "},"chapter1/1.2.html":{"url":"chapter1/1.2.html","title":"为什么使用SSR ?","keywords":"","body":"为什么使用SSR ? 前端需求 组件化能力 响应式编程能力 目前问题 SPA能够满足组件化 + 次屏之后的体验，但是解决不了首屏 + SEO 解决方案 考虑到组件化的能力，提升用户体验，以及兼顾首屏 + SEO，最终决定使用 Vue SSR 方案 Copyright ©大数据项目组 2019 all right reserved，powered by Gitbook本文档更新于： 2019-11-24 21:45 "},"chapter1/1.3.html":{"url":"chapter1/1.3.html","title":"项目架构","keywords":"","body":"项目架构 Vue SSR 渲染路线 SSR由NodeJS服务器来直出页面，请求到达后端后，后端拉取cgi接口数据，根据直出bundle生成render对象，render对象将执行客户端代码构建VDOM，生成HTML string，填充进模板HTML，返回HTML资源，浏览器解析后加载CSS、JS资源，（在CSS加载结束后触发FP和FMP），Vue实例初始化，接管后端直出的HTML，页面可交换。 构建和执行流程 使用 webpack4 来打包我们的 Vue 应用程序。 ├── webpack.base.config.js # 基本配置 (base config) ├── webpack.client.config.js # 客户端配置 (client config) ├── webpack.server.config.js # 服务器配置 (server config) 具体webpack配置代码这里省略...... 对于客户端应用程序和服务器应用程序，我们都要使用Webpack打包， 服务端需要「server bundle」,用于SSR， 而「client bundle」会发送给浏览器，用于混合静态标记。基本流程如下图： Copyright ©大数据项目组 2019 all right reserved，powered by Gitbook本文档更新于： 2019-11-24 21:45 "},"chapter1/1.4.html":{"url":"chapter1/1.4.html","title":"基础功能","keywords":"","body":"基础功能 特性 基于 Vue.js 服务端渲染 强大的路由功能，支持异步数据 支持懒加载 静态文件服务 ES2015+ 语法支持 打包和压缩 JS 和 CSS HTML 头部标签管理 本地开发支持热加载 集成 ESLint 支持样式预处理器： SASS、LESS、 Stylus 模板项目 主要功能 登录 / 注销 权限验证 国际化多语言 Svg Sprite 图标 错误日志 多环境 自适应收缩侧边栏 动态侧边栏（支持多级路由嵌套） 快捷导航(标签页) 组织图 Echart ..... 截图 登录 首页 组织图 Copyright ©大数据项目组 2019 all right reserved，powered by Gitbook本文档更新于： 2019-11-24 21:45 "},"chapter1/1.6.html":{"url":"chapter1/1.6.html","title":"Browsers support","keywords":"","body":"Browsers support Modern browsers and Internet Explorer 10+. IE / Edge Firefox Chrome Safari IE10, IE11, Edge last 2 versions last 2 versions last 2 versions Copyright ©大数据项目组 2019 all right reserved，powered by Gitbook本文档更新于： 2019-11-24 21:45 "},"chapter1/1.5.html":{"url":"chapter1/1.5.html","title":"版本记录","keywords":"","body":"版本记录 v1.0.0 最为基础的项目模板 v2.0.0 开发中.... Copyright ©大数据项目组 2019 all right reserved，powered by Gitbook本文档更新于： 2019-11-24 21:45 "},"chapter5/":{"url":"chapter5/","title":"开源贡献","keywords":"","body":"开源贡献 项目还处于初级阶段，还有许多待优化的地方，欢迎大家提出问题，做出开源贡献！ 如何贡献 有任何疑问，欢迎提交 issue 或者直接修改提交 PR! 交流 欢迎交流讨论，多多指教！ 如果对你有所帮助，欢迎star Copyright ©大数据项目组 2019 all right reserved，powered by Gitbook本文档更新于： 2019-11-24 21:45 "},"chapter2/2.0.html":{"url":"chapter2/2.0.html","title":"快速开始","keywords":"","body":"快速开始 本文将从现有的项目模板，让你快速运行一个Vue SSR项目。 环境准备 操作系统：支持 macOS，Linux，Windows 运行环境：NodeJS，建议选择 LTS 版本，最低要求 8.x。 初始化 直接克隆模板项目，快速生成项目（v2会使用脚手架） $ git clone https://github.com/mopacha/vue-ssr-admin.git $ npm i 启动项目: $ npm run dev $ open http://localhost:3006 Copyright ©大数据项目组 2019 all right reserved，powered by Gitbook本文档更新于： 2019-11-24 21:45 "},"chapter2/2.1.html":{"url":"chapter2/2.1.html","title":"源码结构图","keywords":"","body":"源码结构图 初始化项目完成之后，我们应该能够看到如下的文件结构 整体结构 ├── app.config.js # 端口、代理配置、webpack配置等等 ├── babel.config.js # babel配置 ├── build │ ├── webpack.base.config.js # 基本配置 (base config) │ ├── webpack.client.config.js # 客户端配置 (client config) │ └── webpack.server.config.js # 服务器配置 (server config) ├── config │ ├── default.js # 环境变量配置 │ ├── development.js # 开发环境变量配置 │ └── log4js.js # 日志写入配置 ├── eslintrc.conf.js # eslint配置 ├── LICENSE ├── package.json ├── package-lock.json ├── pm2.config.js # 项目pm2配置 ├── pm2.md # pm2的api文档 ├── postcss.config.js postcss配置文件 ├── public │ ├── favicon.ico #网站图标 │ └── libs # ├── README.md # 文档 ├── server └── src Node 目录结构 server ├── middleware # koa server 中间件 │ ├── mi-cookie-parser │ ├── mi-error │ ├── mi-log │ ├── mi-proxy │ └── index.js ├── utils #工具 ├── server.js # koa2服务详细配置 ├── dev-hot.js # koa2开发模式实现hot热更新 ├── index.js # server入口 └── ssr.js # vue ssr的koa2中间件。匹配路由、请求接口生成dom，实现SSR src 目录结构 src ├── api │ └── index.js # 接口api ├── app.js # 通用 entry ├── App.vue ├── assets # css、images等静态资源目录 ├── components # 项目自定义组件目录 ├── config.js # vue组件、mixins注册 ├── element-ui │ └── index.js # element ui组件按需加载 ├── entry-client.js # 仅运行于浏览器 ├── entry-server.js # 仅运行于服务器 ├── http │ ├── getErrMsg.js # 客户端请求错误处理 │ ├── index-client.js # 客户端http 请求封装 │ ├── index-server.js # 服务端http 请求封装 │ └── README.md ├── icons │ ├── index.js # svg 图标引入封装 │ ├── svg │ └── svgo.yml ├── index.template.ejs # index模板 ├── lang # 国际化语音配置 ├── layout # vue 项目模板 ├── pages # 业务视图.vue和route路由目录 ├── router # 路由route配 ├── settings.js ├── store # vuex数据存储目录 ├── styles └── util # 工具目录 Copyright ©大数据项目组 2019 all right reserved，powered by Gitbook本文档更新于： 2019-11-24 21:45 "},"chapter2/2.2.html":{"url":"chapter2/2.2.html","title":"配置","keywords":"","body":"配置 config 项目采用config来管理项目的配置。更多文档 对应 config 目录如下： ├── config # 项目配置文件目录 ├── default.js # 默认配置 ├── development.js # 开发环境配置 └── log4js.js # log4js 配置项 default.js 默认配置。 //default.js const log4js = require('./log4js') module.exports = { appName: \"vue-ssr\", log4js: log4js, staticHost: \"\", //http://static.cdn.com staticPath: \"/vue-static\", apiHost: \"https://www.fastmock.site\", //后端host apiHost2: \"http://10.114.41.200:8080\" // http://10.114.41.200:8080 } development.js 开发配置，在开发模式时，覆盖默认配置项。 log4js.js log4js日志配置，更多参考log4js使用文档 //log4js.js module.exports = { appenders: { console: { type: 'console' }, app: { type: 'dateFile', filename: `log/vue-ssr-admin`, pattern: '-yyyy-MM-dd.log', alwaysIncludePattern: true, backups: 5, maxLogSize: 10485760, compress: true } }, categories: { default: { appenders: ['console', 'app'], level: 'debug' // ['trace', 'debug', 'info', 'warn', 'error', 'fatal', 'mark'] } }, pm2: true, pm2InstanceVar: 'INSTANCE_ID' } app.config.js 应用的相关配置文件，包括webpack的差异化配置、请求代理配置 //app配置 const path = require('path') const conf = require('./config/default') const devConf = require('./config/development') const isProd = process.env.NODE_ENV === 'production' module.exports = { staticHost: isProd ? conf.staticHost : devConf.staticHost, staticPath: isProd ? conf.staticPath : devConf.staticPath, //webpack的差异化配置 webpack: { entry: { app: path.join(__dirname, 'src/app.js'), // 入口 }, resolveAlias: { // 自定义Alias设置 } }, appPort: process.env.PORT,//主服务启动端口 //代理配置，可支持多个代理，key为前缀，命中后，会把前缀去掉，转发到代理服务器 proxy: { '/fastApp': isProd ? conf.apiHost : devConf.apiHost, '/coolApp': isProd ? conf.apiHost2 : devConf.apiHost2, } } Copyright ©大数据项目组 2019 all right reserved，powered by Gitbook本文档更新于： 2019-11-24 21:45 "},"chapter2/2.3.html":{"url":"chapter2/2.3.html","title":"路由","keywords":"","body":"路由 封装了页面路由，使客户端和服务器复用相同的路由配置。 在 src/router/index.js文件下配置路由 export default store => { return new Router({ mode: 'history', scrollBehavior(to, from, savedPosition) { return { x: 0, y: 0 } }, routes: [ { path: '/login', component: () => import('@/pages/login/index'), hidden: true }, { path: '/404', component: () => import('@/pages/404'), hidden: true }, { path: '/', component: Layout, redirect: '/home', children: [ { path: 'home', name: 'home', component: () => import('@/pages/home/index'), meta: { title: 'home', icon: 'home' } } ] } ] } Copyright ©大数据项目组 2019 all right reserved，powered by Gitbook本文档更新于： 2019-11-24 21:45 "},"chapter2/2.4.html":{"url":"chapter2/2.4.html","title":"编写通用性代码","keywords":"","body":"编写通用性代码 一套代码，两套执行环境 在vue的生命周期函数中，只有beforeCreate和created会在ssr过程中执行，其他的生命周期函数只会在客户端执行。所以应该避免在这两个生命周期函数中产生全局副作用的代码，比如定时器。同时，由于前端代码会在后端中执行，而Node.js和浏览器JavaScript有区别，导致在前端视图中的部分JavaScript属性或方法在执行时会报错。比如在使用一些插件的时候会提示window或document是undefined，在这种情况下，可以用vue-no-ssr让相关组件不走ssr 数据预获取方式 使用asyncData 静态方法 import { mapGetters } from 'vuex' export default { name: 'Home', // 组件实例化前无法访问this，所以需要将store和路由信息作为参数传递进去 asyncData({ store, router }) { return store.dispatch('user/getInfo') }, computed: { ...mapGetters(['userInfo']) } } client端获取数据方式 import API from '@/api' export default { ...... methods: { getData(){ try{ const data = await API(this.$store.$http).getJobSummary() ...... } catch(err=>{ ...... }) } } ...... } Copyright ©大数据项目组 2019 all right reserved，powered by Gitbook本文档更新于： 2019-11-24 21:45 "},"chapter3/3.1.html":{"url":"chapter3/3.1.html","title":"cookies穿透","keywords":"","body":"cookies穿透 由于客户端的http请求首先达到SSR服务器，再由SSR服务器去后端服务器获取相应的接口数据。在客户端到SSR服务器的请求中，客户端是携带有cookie数据的。但是在SSR服务器请求后端接口的过程中，却是没有相应的cookie数据的。因此在SSR服务器进行接口请求的时候，我们需要手动拿到客户端的cookie传给后端服务器。 在ssr期间我们需要截取客户端的cookie，保持用户会话唯一性。 1. 在ssr.js中，将cookies注入到context ...... const context = { url: ctx.url, title: 'VUE-SSR', cookie: ctx.cookie //把cookie 注入到 context 中 } ...... renderer.renderToString(context, (err, html) => { ...... } ...... 2. 在server-entry.js中，将cookies注入到store export default context => { ...... const cookie = context.cookie if (context) { store.state.cookies = context.cookies } ...... // 将http放到store工厂里, 防止cookies污染, 解决客户端与服务端cookie穿透 store.$http = store.state.$http = http(cookie) ...... } Copyright ©大数据项目组 2019 all right reserved，powered by Gitbook本文档更新于： 2019-11-24 21:45 "},"chapter3/3.2.html":{"url":"chapter3/3.2.html","title":"HTTP请求","keywords":"","body":"HTTP请求 区别对待axios在server端与client端处理 1. index-client.js 客户端请求封装 接口统一格式处理 { \"code\":2000, \"message\":\"success\", \"data\":{ }, \"success\":true } 对axios进行封装 对http error: 401、400、403、404、500....统一报错弹窗提示 对 res.code: 2000: OK，!2000统一弹窗提示，错误文案使用res.message //index-client.js import axios from 'axios' import { statusToMsg, codeToMsg } from './getErrMsg' import { removeToken, getToken } from '@/util/auth' import { Message, Loading } from 'element-ui' let loading let count = 0 function startLoading() { if (count > 0) { loading.close() } count++ loading = Loading.service({ lock: true, text: '数据加载中...', background: 'rgba(0, 0, 0, 0)', target: '.app-container' // 设置加载动画区域 }) } function endLoading() { loading.close() count = 0 } const showError = msg => { Message({ showClose: true, message: msg, type: 'error', duration: 3.5 * 1000 }) } export default () => { const service = axios.create({ baseURL: '', timeout: 60 * 1000, // 请求超时时间 60s withCredentials: true }) //请求拦截器 service.interceptors.request.use( config => { startLoading() config.headers['Authorization'] = 'Bearer ' + getToken() return config }, error => { return Promise.error(error) }) service.interceptors.response.use( response => { endLoading() const res = response.data const { code, data } = res if (code === 2000) { return Promise.resolve(data) } else { let errMsg = codeToMsg(code) showError(errMsg) return Promise.reject({ status: 200, code, message: errMsg }) } }, error => { endLoading() const { response, request } = error const { status, data } = response const { method, path } = request let errMsg = '' if (status === 401) { removeToken() window.location.href = '/login' } else { errMsg = statusToMsg(status) if (errMsg) { showError(errMsg) } } return Promise.reject({ status, message: errMsg, data, method, path }) } ) return service } 2. index-server.js 服务端请求封装 !200 、!2000报错，交给entry-server.js处理 //index-server.js import axios from 'axios' import { cookie2Str } from '@/util/cookie-tools' const currentIP = require('ip').address() const appConfig = require('../../app.config') // 发起带 cookies 参数的请求 export default cookie => { const auth_toten = cookie && cookie['vue_ssr_token'] ? `Bearer ` + cookie['vue_ssr_token'] : '' let headers = { Accept: 'application/json, text/plain, */*; charset=utf-8', 'Content-Type': 'application/json; charset=utf-8', Pragma: 'no-cache', 'Cache-Control': 'no-cache', Authorization: auth_toten, 'Cookie': cookie2Str(cookie) } const baseURL = `http://${currentIP}:${appConfig.appPort}` const service = axios.create({ baseURL: baseURL, timeout: 60 * 1000, // 请求超时时间 60s withCredentials: true, headers: headers }) service.interceptors.request.use( config => { return config; }, error => { return Promise.error(error); }) service.interceptors.response.use( response => { const res = response.data const { code, data, message } = res if (code === 2000) { return Promise.resolve(data) } else { return Promise.reject({ status: 200, code, message }) } }, error => { //todo 统一处理500、400等错误状态,这里reject下，交给entry-server.js的处理 const { response, request } = error return Promise.reject({ status: response.status, data: response.data, method: request.method, path: request.path }) } ) return service } Copyright ©大数据项目组 2019 all right reserved，powered by Gitbook本文档更新于： 2019-11-24 21:45 "},"chapter3/3.3.html":{"url":"chapter3/3.3.html","title":"国际化","keywords":"","body":"国际化 见源码 Copyright ©大数据项目组 2019 all right reserved，powered by Gitbook本文档更新于： 2019-11-24 21:45 "},"chapter3/3.4.html":{"url":"chapter3/3.4.html","title":"中间件","keywords":"","body":"中间件 在vue-srr中，使用了许多Koa2的中间件 cookie处理中间件 // 将字符串cooke转成cookie obj module.exports = () => { return async (ctx, next) =>{ const cookieHeader = ctx.headers.cookie if (cookieHeader) { const cookies = cookieHeader.split(';') ctx.cookie = {} cookies.forEach(function (item) { const crumbs = item.split('=') if (crumbs.length > 1) ctx.cookie[crumbs[0].trim()] = crumbs[1].trim() }) } await next() } } http代理中间件 koa-better-http-proxy /** * http代理中间件 匹配代理、请求重定向 * 获取app.config.js配置文件，匹配proxy */ const urlUtils = require('url') const koaHttpProxy = require('koa-better-http-proxy') const compose = require('koa-compose') const appConfig = require('../../../app.config') const isProd = process.env.NODE_ENV === 'production' /** * 代理处理中间件 * @return {Function} koa middleware */ module.exports = () => { async function preProxyMiddleware(ctx, next) { const url = ctx.url //ctx.log.info(`Request '${url}'`) let proxyTarget let proxyConfig = appConfig.proxy // 在appConfig.proxy中寻找匹配前缀的代理 for (const [prefix, target] of Object.entries(proxyConfig)) { if (url.startsWith(prefix)) { // 匹配替换 ctx.url = url.replace(prefix, '') proxyTarget = target ctx._proxyTarget = proxyTarget //ctx.log.info(`Match to proxy: '${prefix}' => '${proxyTarget}'`) break } } if (!proxyTarget) { ctx.log.info('Proxy not found') return Promise.resolve() } //ctx.log.info(`Will be Agent to '${proxyTarget + ctx.url}'`) return next() } /** * 顺序执行async函数 */ return compose([ preProxyMiddleware, koaHttpProxy((ctx) => { return ctx._proxyTarget }, { // 不解析body，不限制body大小 parseReqBody: true, /** * 发出代理请求前的回调,更改头文件 * @param {Object} proxyReqOpts - 代理请求选项 * @param {ctx} ctx - koa ctx * @return {Promise.} * */ async proxyReqOptDecorator(proxyReqOpts, ctx) { const parsedTarget = urlUtils.parse(ctx._proxyTarget, true) proxyReqOpts.host = parsedTarget.hostname proxyReqOpts.port = parsedTarget.port proxyReqOpts.https = parsedTarget.protocol === 'https:' // 去掉Referer头，否则可能会造成CSRF问题，影响开发 if (!isProd) { delete proxyReqOpts.headers.Referer delete proxyReqOpts.headers.Origin } ctx._proxyReqOpts = proxyReqOpts return proxyReqOpts }, //发出代理请求前的回调,请求body async proxyReqBodyDecorator(bodyContent, ctx) { const reqParams = JSON.stringify({ url: ctx._proxyTarget + ctx._proxyReqOpts.path, method: ctx._proxyReqOpts.method, cookie: ctx._proxyReqOpts.headers.cookie }) ctx.log.info(`Request: param is: ${bodyContent}; and ${reqParams}`) // 计时开始 ctx._proxyStartTime = Date.now() return bodyContent }, /** * 代理请求被响应后的回调 * @param {Response} proxyRes - 代理请求选项 * @param {Object} proxyResData - 响应数据 * @param {ctx} ctx - koa ctx * @return {Promise.} * */ async userResDecorator(proxyRes, proxyResData, ctx) { const resParams = JSON.stringify({ cost: Date.now() - ctx._proxyStartTime + 'ms', status: proxyRes.statusCode }) ctx.log.info(`Response: ${resParams} res: ${proxyResData}`) return proxyResData } }) ]) } 静态资源中间件 koa-static //设置静态资源请求目录和设置缓存 app.use(static(path.resolve(process.cwd(), 'dist'), { maxAge: 30 * 24 * 60 * 60 * 1000, gzip: true })) app.use(static(path.resolve(process.cwd(), 'public'))) vue-server-renderer vue-server-renderer是SSR服务器端渲染的核心模块。 server 端生成HTML的步骤: 有一个你想打包.vue文件的入口文件，就是src/entry-server.js 在webpack的配置文件中，把入口文件指向他 使用webpack对打包，会生成vue-ssr-server-bundle.json文件 使用vue-server-renderer包解析这个文件，最终渲染成HTML Copyright ©大数据项目组 2019 all right reserved，powered by Gitbook本文档更新于： 2019-11-24 21:45 "},"chapter3/3.5.html":{"url":"chapter3/3.5.html","title":"log4js日志管理","keywords":"","body":"log4js 日志管理 Node.js 日志管理模块 日志对于 Web 开发的重要性毋庸置疑，它对于监控应用的运行状态、问题排查等都有非常重要的意义。 主要特性： 日志分级 统一错误日志 启动日志和运行日志分离 自定义日志 多进程日志 使用方式 $ npm install log4js koa2中间件中引用，配置文件在config/log4js // 日志处理中间件 const log4js = require('log4js') const config = require('config') const log4jsConf = config.log4js module.exports = () => { let appName = config.appName log4js.configure(log4jsConf) return async (ctx, next) => { const logger =log4js.getLogger(appName) ctx.log = logger await next() } } 在业务中使用 const logger = require('../utils/logger') logger.debug(err) logger.info('info message...') logger.warn('get xxx api failed:', error); Copyright ©大数据项目组 2019 all right reserved，powered by Gitbook本文档更新于： 2019-11-24 21:45 "},"chapter3/3.6.html":{"url":"chapter3/3.6.html","title":"异常处理","keywords":"","body":"异常处理 异常来自哪里？ server端数据预获取异常：数据异常，接口异常 server端 renderer.renderToString 异常 处理方式 1. server 端获取数据异常，让页面继续渲染，在页面加入标志，让client端重新获取数据，代码如下： entry-server.js服务端部分 // entry-server.js服务端部分 Promise.all(matcheds.map(Component => { ...... })) .then(() => { ..... }).catch(err => { // 交给服务端重定向 if (err.status === 401) { reject(err) } //增加服务端预渲染错误标识，前端拿到标志后重新渲染 context.state = Object.assign(store.state, { serverError: true }) //最后，将服务端vue实例正常返回，避免抛500 resolve(app) }) entry-client.js客户端部分： //entry-client.js ...... router.onReady((currentRoute) => { // node报错时前端路由重渲染(非401状态， 401已经在服务端重定向) function feCompatibleRende(route) { let matched = router.getMatchedComponents(route) console.log('客户端重新AJAX') Promise.all(matched.map(c => { if (c.asyncData) { return c.asyncData({ store, router, route }) } })) } if (window.__INITIAL_STATE__.serverError) { feCompatibleRende(currentRoute) } ...... }) 2. server 页面渲染过程的异常，出现的问题概率较小，服务端重定向到指定的错误页面 app.use(async (ctx, next) => { ...... try { status = 200 html = await renderData(ctx, renderer) } catch (e) { if (e.status === 404) { status = 404 return ctx.redirect('/404') } else if (e.status === 401) { status = 401 return ctx.redirect('/login') } else { status = 500 return ctx.redirect('/500') } } ...... }) Copyright ©大数据项目组 2019 all right reserved，powered by Gitbook本文档更新于： 2019-11-24 21:45 "},"chapter3/3.7.html":{"url":"chapter3/3.7.html","title":"应用部署","keywords":"","body":"应用部署 在本地开发时，我们使用 npm run dev 来启动服务，但是在部署应用的时候不可以这样使用。因为 npm run dev 会针对本地开发做很多处理，而生产运行需要一个更加简单稳定的方式。所以本章主要讲解如何部署你的应用。 一般从源码代码到真正运行，我们会拆分成构建和部署两步，可以做到一次构建多次部署。 构建 $ npm install $ npm run build 目前执行完 npm run build 后，会在当前目录下生成dist目录, 此目录下既有server bundle,也有client bundle。 后续优化： 使用gulp工具分开，client bundle 部署到CDN 打包完成后， server side 只安装 dependencies 的依赖。 devDependencies 中的模块过大而且在生产环境不会使用，安装后也可能遇到未知问题。 部署 操作系统：Linux 运行环境：NodeJS >=8，建议选择 LTS 版本 安装pm2 npm i -g pm2 安装pm2-intercom pm2 install pm2-intercom 启动命令 $ pm2 start pm2.config.js --env production 启动配置项 在 pm2.config.js中配置指定启动配置。 //pm2.config.js module.exports = { apps: [{ ...... name: 'vue-ssr-admin', // app名称 script: 'server/index.js', // 要运行的脚本的路径。 args: '', // 由传递给脚本的参数组成的字符串或字符串数​​组。 output: './log/out.log', error: './log/error.log', log: './log/combined.outerr.log', merge_logs: true, // 集群的所有实例的日志文件合并 log_date_format: \"YYYY-MM-DD HH:mm Z\", instances: \"max\", // 进程数 1、数字 2、'max'根据cpu内核数 instance_var: \"INSTANCE_ID\", max_memory_restart: '1G', // 当内存超过1024M时自动重启 watching: true, env: { NODE_ENV: 'production', PORT: 8066 }, ...... }], } 停止命令 $ pm2 delete vue-ssr-admin Copyright ©大数据项目组 2019 all right reserved，powered by Gitbook本文档更新于： 2019-11-24 21:45 "},"chapter4/":{"url":"chapter4/","title":"常见问题","keywords":"","body":"常见问题 mini-css-extract-plugin在SSR上不能用 原因：这个插件会用document方法，往模板插入标签。服务器渲染跑的是node.js环境里没有document这个方法，就会报错：document is not defined。 解决方案： webpack.server.config.js 端屏蔽 //屏蔽方法 class ServerMiniCssExtractPlugin extends MiniCssExtractPlugin { getCssChunkObject(mainChunk) { return {}; } } webpack.client.config.js端 正常使用mini-css-extract-plugin 集群模式PM2+Log4js 写入Log失败 log4js的配置中增加这两个配置 { pm2: true, pm2InstanceVar: \"INSTANCE_ID\" // 与pm2的配置对应 } 安装pm2-intercom; pm2 install pm2-intercom element-ui的组件 el-table 不支持服务端渲染 github 上面 elment-ui 已经提issue，还未修复。暂不影响业务功能 svg-sprite-loader 在server端转换不成功 1. 在entry-server.js中把symbolContent 放在 context中 //entry-server.js import getSvgContent from '@/util/svg-spirate' export default (context) => { return new Promise((resolve, reject) => { ...... context.svgContent = getSvgContent() // 把svg-symbol 交给server-render ...... } // @/util/svg-spirate export default () => { const req = require.context('@/icons/svg', false, /\\.svg$/) const requireAll = requireContext => requireContext.keys().map(i => requireContext(i)) const svgContent = requireAll(req) let symbolContent = '' svgContent.map(item => { symbolContent = symbolContent + item.default.content }) const pageContent = ` ${symbolContent} ` return pageContent } 2. 在server端将 svgContent注入到html中 //renderer.renderToString 开始执行行entry-erver.js renderer.renderToString(context, (err, html) => { if (err) { ctx.log.debug(`renderToString:`, err) return reject(err) } const svgContent = context.svgContent const $ = cheerio.load(html) $('body').prepend(svgContent) resolve($.html()) }) 关于storage、document、window的使用 在vue的生命周期函数中，beforeCreate和created会在服务端和客户端执行，其他钩子都在客户端执行，所以，如果在beforeCreate和created，或是直接在vuex和router入口文件中使用了storage、document以及window这些在浏览器端js才有的属性或对象时，就会报错。为了避免这个问题，应该在客户端渲染的钩子中执行。 Copyright ©大数据项目组 2019 all right reserved，powered by Gitbook本文档更新于： 2019-11-24 21:45 "}}